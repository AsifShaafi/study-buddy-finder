General Notes:
- I was able to get an instance of the complete project running in the cloud and accessible from my local machine. I did this by setting up a VM in GCP, downloading Docker on it, installing a GitLab runner on it, and configuring the GitLab runner to execute a set of commands that built and deployed the frontend and backend images. Not sure if this is what the team had in mind for cloud deployments, but this seemed the most straightforward. It is possible to run the GitLab runner in a Kubernetes cluster and deploy the containers there, but from my understanding that would require multiple runners, as you would need one running in a VM to build the images, store those in a container registry, and then have the runner hosted in the Kubernetes cluster grab those images and deploy them as containers. Coincidentally, I have some experience doing something similar using Terraform, so if that is something the team wants to explore, I may be able to help. But simply setting up a VM to act as the prod server seemed like the best solution.
- To access the running applications, I exposed the VM to the internet. GCP assigns it an IP address that you can use to access its endpoints from any machine. I'm not sure if we're okay with that approach for the project; it seems a little public. If we wanted to configure a more secure way of accessing the server, I'm not sure how that would be done as I lack experience with that.
- To get this to work, I moved the Dockerfiles found in the 'docker' folder to their respective (road-trip-api and road-trip-frontend) directories and renamed them each to "Dockerfile". I also renamed the docker-compose file to "docker-compose.yml" and put it in the root directory. I then wrote the gitlab-cli.yml file with the assumption that those changes had been made. I'm assuming that's the intended use, and they were placed in the "docker" directory to help inform the students of what they do, but just wanted to call that out in case I'm misunderstanding that.
    - the Dockerfile for road-trip-api did not work for me. The Gradle build step did not generate any files that "road-trip-api-*.jar" would match. To get around this, I changed that to point to "build-1.0-SNAPSHOT.jar", as I saw it was generating this file. This did not actually work; it would deploy an app that only returned 404 errors, but I just used that to see something was being exposed during testing.
- This is probably a naive comment, but I'm not sure how all 3 containers will talk to each other. It should function the exact same way as it's configured to locally, since the server is just a VM running the containers, but just wanted to call that out in case more configuration needs to be done on the GCP side.

CI/CD Steps 
- Setup an account with GCP if you don't already have one.
- Create a Linux VM: This will be your production server.
    - Enable the Compute Engine API, and create a Linux VM.
    - check the options for allowing both HTTP and HTTPS traffic to the VM. This should give your VM an external IP address once it's created.
    - Navigate to "VM instances" tab and click the "Set up firewall rules" option.
    - Select the "default-allow-http" rule, and select "Edit" at the top of the page.
    - In the "TCP Ports" section, add 8080 and 3000. This will allow you to access those ports from your local machine. If, in the future, you need to add more or different HTTP ports, you would do so in the same way. Also, if you want to add HTTPS ports, you would do so in the same way, just under the "default-allow-https" rule.
- setup a GitLab runner: The GitLab runner waits for commits to be made to the branch it is configured to watch and runs a user-defined set of commands when one occurs. This runner must be linked to your repository first.
    - open an SSH terminal to the VM
    - install a GitLab runner on the VM using the following instructions (for Debian/Ubuntu/Mint): https://docs.gitlab.com/runner/install/linux-repository.html 
    - register the GitLab runner using the following instructions (for Linux; The runner executor should be 'shell'): https://docs.gitlab.com/runner/register/index.html 
    - install docker on your VM, using the following instructions (using the repository): https://docs.docker.com/engine/install/debian/#install-using-the-repository 
    - run the following command, giving your gitlab runner permissions to run docker commands: `sudo usermod -aG docker gitlab-runner` 
- Write a gitlab-cli.yml file.
    - This file tells the GitLab runner what to do whenever a commit is made to the branch the file is in; You can learn more here: https://docs.gitlab.com/ee/ci/quick_start/
    - We want our runner to build a docker image for both our frontend and backend on a commit and then deploy those images as containers, along with our database image, to our production server. The way this is done is largely up to you; we have provided sample Dockerfiles and a sample gitlab-cli.yml file to give an example of how it could be done.
    - whenever a commit is made, a pipeline should be created for your GitLab project. You can view this pipeline to see its status while it is executing in the "CI/CD -> Pipelines" tab on GitLab.

This will get basic CI/CD functionality setup for your project. Feel free to customize this process to fit your needs as the project progresses.
